# TypeScript Standards

This project follows strict TypeScript standards to ensure type safety and code quality.

## Avoid "any" Type

**Rule**: Avoid using the `any` type as much as possible. TypeScript's strength lies in its type system, and using `any` defeats this purpose.

### ❌ Incorrect Usage
```typescript
function processData(data: any): any {
  return data.someProperty;
}

const result: any = someFunction();
```

### ✅ Correct Usage
```typescript
interface DataType {
  someProperty: string;
  otherProperty: number;
}

function processData(data: DataType): string {
  return data.someProperty;
}

const result: DataType = someFunction();
```

## Type Definitions

### Models Should Provide Types
- Models should export proper TypeScript types for all their properties
- Use the model's exported types instead of `any`
- Create interfaces for complex data structures

### When Types Are Unknown
If the exact type is unknown, use more specific alternatives:

```typescript
// Instead of 'any', use:
unknown          // For truly unknown data that needs type checking
object          // For objects
Record<string, unknown>  // For object with string keys
Array<unknown>  // For arrays of unknown items
```

### Database Documents
```typescript
// ❌ Don't use any
const doc: any = await Model.findOne();

// ✅ Use proper model types
const doc: InstanceType<TModelType> | null = await Model.findOne();
```

### API Responses
```typescript
// ❌ Don't use any
const response: any = await fetch('/api/data');

// ✅ Define response interface
interface ApiResponse {
  data: DataType[];
  total: number;
  page: number;
}
const response: ApiResponse = await fetch('/api/data');
```

### Error Handling
```typescript
// ❌ Don't use any
catch (error: any) {
  console.log(error.message);
}

// ✅ Use proper error typing
catch (error: unknown) {
  if (error instanceof Error) {
    console.log(error.message);
  }
}
```

## Type Assertions

When you must work with dynamic data, use type assertions carefully:

```typescript
// ❌ Avoid casting to any
const data = response as any;

// ✅ Use specific type assertions
const data = response as ExpectedType;

// ✅ Or use type guards
function isExpectedType(obj: unknown): obj is ExpectedType {
  return typeof obj === 'object' && obj !== null && 'expectedProperty' in obj;
}
```

## Utility Types

Use TypeScript's built-in utility types:

```typescript
// For partial updates
Partial<ModelType>

// For picking specific properties
Pick<ModelType, 'prop1' | 'prop2'>

// For omitting properties
Omit<ModelType, 'sensitiveField'>

// For making properties optional
Optional<ModelType, 'optionalField'>
```

## Important Rules

1. **Always prefer specific types** over `any`
2. **Create interfaces** for complex data structures
3. **Use model-exported types** when working with database documents
4. **Use type guards** when dealing with unknown data
5. **Document why** if you absolutely must use `any` (should be extremely rare)
6. **Use `unknown`** instead of `any` when the type is truly unknown
7. **Leverage TypeScript's inference** - let TypeScript infer types when possible

## Exceptions

The only acceptable use of `any` is when:
- Working with legacy JavaScript libraries without type definitions
- Temporary during migration from JavaScript to TypeScript
- Must be documented with a comment explaining why

```typescript
// Acceptable only with explanation
const legacyLib: any = require('old-library'); // TODO: Add type definitions
```
